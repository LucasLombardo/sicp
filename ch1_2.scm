; Example: Factorial procedure using linear recursion
  ; This is a recursive procedure AND a recursive process
  (define (factorial n)
    (if (= n 1)
      1
      (* n (factorial (- n 1)))
    )
  )


; Example: Factorial procedure using linear iteration
  ; This is a recursive procedure, but an iterative process, AKA a tail recursion
  ;   => The actual process maintains state in the variables for each step, rather
  ;      than having a sort of hidden state only visable in the interpreter
  (define (factorial n)
    (fact-iter 1 1 n)
  )

  (define (fact-iter product counter max-count)
    (if (> counter max-count)
      product
      (fact-iter (* counter product)
        (+ counter 1)
        max-count
      )
    )
  )


; Exercise 1.9.  Each of the following two procedures defines a method for adding two positive
  ; integers in terms of the procedures inc, which increments its argument by 1, and dec, which
  ; decrements its argument by 1.

  (define (+ a b)
    (if (= a 0)
      b
      (inc (+ (dec a) b))
    )
  )

  (define (+ a b)
    (if (= a 0)
      b
      (+ (dec a) (inc b))
    )
  )

  ; Using the substitution model, illustrate the process generated by each procedure in evaluating
  ; (+ 4 5). Are these processes iterative or recursive?

  ; Answer: while both procedures are recursive, only the first one has a recursive process. This is
  ; because with each step it takes, it nests one more `inc` call and when it finally hits the base case
  ; of `a` being 0 it works its way out, incrementing the original `b` value on its way.
  
  ; The second procedure is a tail-recursive procedure and an iterative process since it maintains its' state
  ; with each step, which is essentially its total value in this case. Since it is just altering `a` and `b`, when
  ; it reaches the base case of `a` being 0, it doesn't need to do anything else - `b` is the answer. 